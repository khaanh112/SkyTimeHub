{"version":3,"file":"index.js","sources":["../../../src/utils.ts","../../../src/extra/packRules.ts","../../../src/extra/permittedFieldsOf.ts","../../../src/extra/rulesToFields.ts","../../../src/extra/rulesToQuery.ts"],"sourcesContent":["import { AnyObject, Subject, SubjectType, SubjectClass, ForcedSubject, AliasesMap } from './types';\n\nconst hasOwn: (o: object, v: PropertyKey) => boolean = Object.hasOwn ||\n  ((obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop));\n\nexport function wrapArray<T>(value: T[] | T): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n\nconst FORBIDDEN_PROPERTIES = new Set(['__proto__', 'constructor', 'prototype']);\nexport function setByPath(object: AnyObject, path: string, value: unknown): void {\n  let ref = object;\n  let lastKey = path;\n\n  if (path.indexOf('.') !== -1) {\n    const keys = path.split('.');\n\n    lastKey = keys.pop()!;\n    ref = keys.reduce((res, prop) => {\n      if (FORBIDDEN_PROPERTIES.has(prop)) return res;\n      res[prop] = res[prop] || {};\n      return res[prop] as AnyObject;\n    }, object);\n  }\n\n  if (!FORBIDDEN_PROPERTIES.has(lastKey)) {\n    ref[lastKey] = value;\n  }\n}\n\nconst TYPE_FIELD = '__caslSubjectType__';\nexport function setSubjectType<\n  T extends string,\n  U extends Record<PropertyKey, any>\n>(type: T, object: U): U & ForcedSubject<T> {\n  if (object) {\n    if (!hasOwn(object, TYPE_FIELD)) {\n      Object.defineProperty(object, TYPE_FIELD, { value: type });\n    } else if (type !== object[TYPE_FIELD]) {\n      throw new Error(`Trying to cast object to subject type ${type} but previously it was casted to ${object[TYPE_FIELD]}`);\n    }\n  }\n\n  return object as U & ForcedSubject<T>;\n}\n\nexport const isSubjectType = (value: unknown): value is SubjectType => {\n  const type = typeof value;\n  return type === 'string' || type === 'function';\n};\n\nconst getSubjectClassName = (value: SubjectClass) => value.modelName || value.name;\nexport function getSubjectTypeName(value: SubjectType) {\n  return typeof value === 'string' ? value : getSubjectClassName(value);\n}\n\nexport function detectSubjectType(object: Exclude<Subject, SubjectType>): string {\n  if (hasOwn(object, TYPE_FIELD)) {\n    return object[TYPE_FIELD];\n  }\n\n  return getSubjectClassName(object.constructor as SubjectClass);\n}\n\nexport const DETECT_SUBJECT_TYPE_STRATEGY = {\n  function: (object: Exclude<Subject, SubjectType>) => object.constructor as SubjectClass,\n  string: detectSubjectType\n};\n\ntype AliasMerge = (actions: string[], action: string | string[]) => string[];\nfunction expandActions(aliasMap: AliasesMap, rawActions: string | string[], merge: AliasMerge) {\n  let actions = wrapArray(rawActions);\n  let i = 0;\n\n  while (i < actions.length) {\n    const action = actions[i++];\n\n    if (hasOwn(aliasMap, action)) {\n      actions = merge(actions, aliasMap[action]);\n    }\n  }\n\n  return actions;\n}\n\nfunction findDuplicate(actions: string[], actionToFind: string | string[]) {\n  if (typeof actionToFind === 'string' && actions.indexOf(actionToFind) !== -1) {\n    return actionToFind;\n  }\n\n  for (let i = 0; i < actionToFind.length; i++) {\n    if (actions.indexOf(actionToFind[i]) !== -1) return actionToFind[i];\n  }\n\n  return null;\n}\n\nconst defaultAliasMerge: AliasMerge = (actions, action) => actions.concat(action);\nfunction validateForCycles(aliasMap: AliasesMap, reservedAction: string) {\n  if (reservedAction in aliasMap) {\n    throw new Error(`Cannot use \"${reservedAction}\" as an alias because it's reserved action.`);\n  }\n\n  const keys = Object.keys(aliasMap);\n  const mergeAliasesAndDetectCycles: AliasMerge = (actions, action) => {\n    const duplicate = findDuplicate(actions, action);\n    if (duplicate) throw new Error(`Detected cycle ${duplicate} -> ${actions.join(', ')}`);\n\n    const isUsingReservedAction = typeof action === 'string' && action === reservedAction\n      || actions.indexOf(reservedAction) !== -1\n      || Array.isArray(action) && action.indexOf(reservedAction) !== -1;\n    if (isUsingReservedAction) throw new Error(`Cannot make an alias to \"${reservedAction}\" because this is reserved action`);\n\n    return actions.concat(action);\n  };\n\n  for (let i = 0; i < keys.length; i++) {\n    expandActions(aliasMap, keys[i], mergeAliasesAndDetectCycles);\n  }\n}\n\nexport type AliasResolverOptions = { skipValidate?: boolean; anyAction?: string };\nexport function createAliasResolver(aliasMap: AliasesMap, options?: AliasResolverOptions) {\n  if (!options || options.skipValidate !== false) {\n    validateForCycles(aliasMap, options && options.anyAction || 'manage');\n  }\n\n  return (action: string | string[]) => expandActions(aliasMap, action, defaultAliasMerge);\n}\n\nfunction copyArrayTo<T>(dest: T[], target: T[], start: number) {\n  for (let i = start; i < target.length; i++) {\n    dest.push(target[i]);\n  }\n}\n\nexport function mergePrioritized<T extends { priority: number }>(\n  array?: T[],\n  anotherArray?: T[]\n): T[] {\n  if (!array || !array.length) {\n    return anotherArray || [];\n  }\n\n  if (!anotherArray || !anotherArray.length) {\n    return array || [];\n  }\n\n  let i = 0;\n  let j = 0;\n  const merged: T[] = [];\n\n  while (i < array.length && j < anotherArray.length) {\n    if (array[i].priority < anotherArray[j].priority) {\n      merged.push(array[i]);\n      i++;\n    } else {\n      merged.push(anotherArray[j]);\n      j++;\n    }\n  }\n\n  copyArrayTo(merged, array, i);\n  copyArrayTo(merged, anotherArray, j);\n\n  return merged;\n}\n\nexport function getOrDefault<K, V>(map: Map<K, V>, key: K, defaultValue: () => V) {\n  let value = map.get(key);\n\n  if (!value) {\n    value = defaultValue();\n    map.set(key, value);\n  }\n\n  return value;\n}\n\nexport const identity = <T>(x: T) => x;\n","\nimport { RawRule } from '../RawRule';\nimport { SubjectType } from '../types';\nimport { wrapArray } from '../utils';\n\nconst joinIfArray = (value: string | string[]) => Array.isArray(value) ? value.join(',') : value;\n\nexport type PackRule<T extends RawRule<any, any>> =\n  [string, string] |\n  [string, string, T['conditions']] |\n  [string, string, T['conditions'] | 0, 1] |\n  [string, string, T['conditions'] | 0, 1 | 0, string] |\n  [string, string, T['conditions'] | 0, 1 | 0, string | 0, string];\n\nexport type PackSubjectType<T extends SubjectType> = (type: T) => string;\n\nexport function packRules<T extends RawRule<any, any>>(\n  rules: T[],\n  packSubject?: PackSubjectType<T['subject']>\n): PackRule<T>[] {\n  return rules.map((rule) => {\n    const packedRule: PackRule<T> = [\n      joinIfArray((rule as any).action || (rule as any).actions),\n      typeof packSubject === 'function'\n        ? wrapArray(rule.subject).map(packSubject).join(',')\n        : joinIfArray(rule.subject),\n      rule.conditions || 0,\n      rule.inverted ? 1 : 0,\n      rule.fields ? joinIfArray(rule.fields) : 0,\n      rule.reason || ''\n    ];\n\n    while (packedRule.length > 0 && !packedRule[packedRule.length - 1]) packedRule.pop();\n\n    return packedRule;\n  });\n}\n\nexport type UnpackSubjectType<T extends SubjectType> = (type: string) => T;\n\nexport function unpackRules<T extends RawRule<any, any>>(\n  rules: PackRule<T>[],\n  unpackSubject?: UnpackSubjectType<T['subject']>\n): T[] {\n  return rules.map(([action, subject, conditions, inverted, fields, reason]) => {\n    const subjects = subject.split(',');\n    const rule = {\n      inverted: !!inverted,\n      action: action.split(','),\n      subject: typeof unpackSubject === 'function'\n        ? subjects.map(unpackSubject)\n        : subjects\n    } as T;\n\n    if (conditions) rule.conditions = conditions;\n    if (fields) rule.fields = fields.split(',');\n    if (reason) rule.reason = reason;\n\n    return rule;\n  });\n}\n","import { AnyAbility } from '../PureAbility';\nimport { Rule } from '../Rule';\nimport { RuleOf } from '../RuleIndex';\nimport { Subject, SubjectType } from '../types';\n\nexport type GetRuleFields<R extends Rule<any, any>> = (rule: R) => string[];\n\nexport interface PermittedFieldsOptions<T extends AnyAbility> {\n  fieldsFrom: GetRuleFields<RuleOf<T>>\n}\n\nexport function permittedFieldsOf<T extends AnyAbility>(\n  ability: T,\n  action: Parameters<T['can']>[0],\n  subject: Parameters<T['can']>[1],\n  options: PermittedFieldsOptions<T>\n): string[] {\n  const subjectType = ability.detectSubjectType(subject);\n  const rules = ability.possibleRulesFor(action, subjectType);\n  const uniqueFields = new Set<string>();\n  const deleteItem = uniqueFields.delete.bind(uniqueFields);\n  const addItem = uniqueFields.add.bind(uniqueFields);\n  let i = rules.length;\n\n  while (i--) {\n    const rule = rules[i];\n    if (rule.matchesConditions(subject)) {\n      const toggle = rule.inverted ? deleteItem : addItem;\n      options.fieldsFrom(rule).forEach(toggle);\n    }\n  }\n\n  return Array.from(uniqueFields);\n}\n\nexport type GetSubjectTypeAllFieldsExtractor = (subjectType: SubjectType) => string[];\n\n/**\n * Helper class to make custom `accessibleFieldsBy` helper function\n */\nexport class AccessibleFields<T extends Subject> {\n  constructor(\n    private readonly _ability: AnyAbility,\n    private readonly _action: string,\n    private readonly _getAllFields: GetSubjectTypeAllFieldsExtractor\n  ) {}\n\n  /**\n   * Returns accessible fields for Model type\n   */\n  ofType(subjectType: Extract<T, SubjectType>): string[] {\n    return permittedFieldsOf(this._ability, this._action, subjectType, {\n      fieldsFrom: this._getRuleFields(subjectType)\n    });\n  }\n\n  /**\n   * Returns accessible fields for particular document\n   */\n  of(subject: Exclude<T, SubjectType>): string[] {\n    return permittedFieldsOf(this._ability, this._action, subject, {\n      fieldsFrom: this._getRuleFields(this._ability.detectSubjectType(subject))\n    });\n  }\n\n  private _getRuleFields(type: SubjectType): GetRuleFields<RuleOf<AnyAbility>> {\n    return (rule) => (rule.fields || this._getAllFields(type));\n  }\n}\n","import { PureAbility } from '../PureAbility';\nimport { AnyObject, ExtractSubjectType } from '../types';\nimport { setByPath } from '../utils';\n\n/**\n * Extracts rules condition values into an object of default values\n */\nexport function rulesToFields<T extends PureAbility<any, AnyObject>>(\n  ability: T,\n  action: Parameters<T['rulesFor']>[0],\n  subjectType: ExtractSubjectType<Parameters<T['rulesFor']>[1]>,\n): AnyObject {\n  return ability.rulesFor(action, subjectType)\n    .reduce((values, rule) => {\n      if (rule.inverted || !rule.conditions) {\n        return values;\n      }\n\n      return Object.keys(rule.conditions).reduce((fields, fieldName) => {\n        const value = rule.conditions![fieldName];\n\n        if (!value || (value as any).constructor !== Object) {\n          setByPath(fields, fieldName, value);\n        }\n\n        return fields;\n      }, values);\n    }, {} as AnyObject);\n}\n","import { CompoundCondition, Condition, buildAnd, buildOr } from '@ucast/mongo2js';\nimport { AnyAbility } from '../PureAbility';\nimport { Generics, RuleOf } from '../RuleIndex';\nimport { ExtractSubjectType } from '../types';\n\nexport type RuleToQueryConverter<T extends AnyAbility, R = object> = (rule: RuleOf<T>) => R;\nexport interface AbilityQuery<T = object> {\n  $or?: T[]\n  $and?: T[]\n}\n\nexport function rulesToQuery<T extends AnyAbility, R = object>(\n  ability: T,\n  action: Parameters<T['rulesFor']>[0],\n  subjectType: ExtractSubjectType<Parameters<T['rulesFor']>[1]>,\n  convert: RuleToQueryConverter<T, R>\n): AbilityQuery<R> | null {\n  const $and: Generics<T>['conditions'][] = [];\n  const $or: Generics<T>['conditions'][] = [];\n  const rules = ability.rulesFor(action, subjectType);\n\n  for (let i = 0; i < rules.length; i++) {\n    const rule = rules[i];\n    const list = rule.inverted ? $and : $or;\n\n    if (!rule.conditions) {\n      if (rule.inverted) {\n        // stop if inverted rule without fields and conditions\n        // Example:\n        // can('read', 'Post', { id: 2 })\n        // cannot('read', \"Post\")\n        // can('read', 'Post', { id: 5 })\n        break;\n      } else {\n        // if it allows reading all types then remove previous conditions\n        // Example:\n        // can('read', 'Post', { id: 1 })\n        // can('read', 'Post')\n        // cannot('read', 'Post', { status: 'draft' })\n        return $and.length ? { $and } : {};\n      }\n    } else {\n      list.push(convert(rule));\n    }\n  }\n\n  // if there are no regular conditions and the where no rule without condition\n  // then user is not allowed to perform this action on this subject type\n  if (!$or.length) return null;\n  return $and.length ? { $or, $and } : { $or };\n}\n\nfunction ruleToAST(rule: RuleOf<AnyAbility>): Condition {\n  if (!rule.ast) {\n    throw new Error(`Ability rule \"${JSON.stringify(rule)}\" does not have \"ast\" property. So, cannot be used to generate AST`);\n  }\n\n  return rule.inverted ? new CompoundCondition('not', [rule.ast]) : rule.ast;\n}\n\nexport function rulesToAST<T extends AnyAbility>(\n  ability: T,\n  action: Parameters<T['rulesFor']>[0],\n  subjectType: ExtractSubjectType<Parameters<T['rulesFor']>[1]>,\n): Condition | null {\n  const query = rulesToQuery(ability, action, subjectType, ruleToAST) as AbilityQuery<Condition>;\n\n  if (query === null) {\n    return null;\n  }\n\n  if (!query.$and) {\n    return query.$or ? buildOr(query.$or) : buildAnd([]);\n  }\n\n  if (query.$or) {\n    query.$and.push(buildOr(query.$or));\n  }\n\n  return buildAnd(query.$and);\n}\n"],"names":["wrapArray","value","Array","isArray","FORBIDDEN_PROPERTIES","Set","setByPath","object","path","ref","lastKey","indexOf","keys","split","pop","reduce","res","prop","has","joinIfArray","join","packRules","rules","packSubject","map","rule","packedRule","action","actions","subject","conditions","inverted","fields","reason","length","unpackRules","unpackSubject","_ref","subjects","permittedFieldsOf","ability","options","subjectType","detectSubjectType","possibleRulesFor","uniqueFields","deleteItem","delete","bind","addItem","add","i","matchesConditions","toggle","fieldsFrom","forEach","from","AccessibleFields","_ability","_action","_getAllFields","this","_proto","prototype","ofType","_getRuleFields","of","type","_this","rulesToFields","rulesFor","values","Object","fieldName","constructor","rulesToQuery","convert","$and","$or","list","push","ruleToAST","ast","Error","JSON","stringify","CompoundCondition","rulesToAST","query","buildOr","buildAnd"],"mappings":"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"}