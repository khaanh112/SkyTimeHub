{"version":3,"file":"index.js","sources":["../../src/utils.ts","../../src/Rule.ts","../../src/structures/LinkedItem.ts","../../src/RuleIndex.ts","../../src/PureAbility.ts","../../src/matchers/conditions.ts","../../src/matchers/field.ts","../../src/Ability.ts","../../src/AbilityBuilder.ts","../../src/ForbiddenError.ts"],"sourcesContent":["import { AnyObject, Subject, SubjectType, SubjectClass, ForcedSubject, AliasesMap } from './types';\n\nconst hasOwn: (o: object, v: PropertyKey) => boolean = Object.hasOwn ||\n  ((obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop));\n\nexport function wrapArray<T>(value: T[] | T): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n\nconst FORBIDDEN_PROPERTIES = new Set(['__proto__', 'constructor', 'prototype']);\nexport function setByPath(object: AnyObject, path: string, value: unknown): void {\n  let ref = object;\n  let lastKey = path;\n\n  if (path.indexOf('.') !== -1) {\n    const keys = path.split('.');\n\n    lastKey = keys.pop()!;\n    ref = keys.reduce((res, prop) => {\n      if (FORBIDDEN_PROPERTIES.has(prop)) return res;\n      res[prop] = res[prop] || {};\n      return res[prop] as AnyObject;\n    }, object);\n  }\n\n  if (!FORBIDDEN_PROPERTIES.has(lastKey)) {\n    ref[lastKey] = value;\n  }\n}\n\nconst TYPE_FIELD = '__caslSubjectType__';\nexport function setSubjectType<\n  T extends string,\n  U extends Record<PropertyKey, any>\n>(type: T, object: U): U & ForcedSubject<T> {\n  if (object) {\n    if (!hasOwn(object, TYPE_FIELD)) {\n      Object.defineProperty(object, TYPE_FIELD, { value: type });\n    } else if (type !== object[TYPE_FIELD]) {\n      throw new Error(`Trying to cast object to subject type ${type} but previously it was casted to ${object[TYPE_FIELD]}`);\n    }\n  }\n\n  return object as U & ForcedSubject<T>;\n}\n\nexport const isSubjectType = (value: unknown): value is SubjectType => {\n  const type = typeof value;\n  return type === 'string' || type === 'function';\n};\n\nconst getSubjectClassName = (value: SubjectClass) => value.modelName || value.name;\nexport function getSubjectTypeName(value: SubjectType) {\n  return typeof value === 'string' ? value : getSubjectClassName(value);\n}\n\nexport function detectSubjectType(object: Exclude<Subject, SubjectType>): string {\n  if (hasOwn(object, TYPE_FIELD)) {\n    return object[TYPE_FIELD];\n  }\n\n  return getSubjectClassName(object.constructor as SubjectClass);\n}\n\nexport const DETECT_SUBJECT_TYPE_STRATEGY = {\n  function: (object: Exclude<Subject, SubjectType>) => object.constructor as SubjectClass,\n  string: detectSubjectType\n};\n\ntype AliasMerge = (actions: string[], action: string | string[]) => string[];\nfunction expandActions(aliasMap: AliasesMap, rawActions: string | string[], merge: AliasMerge) {\n  let actions = wrapArray(rawActions);\n  let i = 0;\n\n  while (i < actions.length) {\n    const action = actions[i++];\n\n    if (hasOwn(aliasMap, action)) {\n      actions = merge(actions, aliasMap[action]);\n    }\n  }\n\n  return actions;\n}\n\nfunction findDuplicate(actions: string[], actionToFind: string | string[]) {\n  if (typeof actionToFind === 'string' && actions.indexOf(actionToFind) !== -1) {\n    return actionToFind;\n  }\n\n  for (let i = 0; i < actionToFind.length; i++) {\n    if (actions.indexOf(actionToFind[i]) !== -1) return actionToFind[i];\n  }\n\n  return null;\n}\n\nconst defaultAliasMerge: AliasMerge = (actions, action) => actions.concat(action);\nfunction validateForCycles(aliasMap: AliasesMap, reservedAction: string) {\n  if (reservedAction in aliasMap) {\n    throw new Error(`Cannot use \"${reservedAction}\" as an alias because it's reserved action.`);\n  }\n\n  const keys = Object.keys(aliasMap);\n  const mergeAliasesAndDetectCycles: AliasMerge = (actions, action) => {\n    const duplicate = findDuplicate(actions, action);\n    if (duplicate) throw new Error(`Detected cycle ${duplicate} -> ${actions.join(', ')}`);\n\n    const isUsingReservedAction = typeof action === 'string' && action === reservedAction\n      || actions.indexOf(reservedAction) !== -1\n      || Array.isArray(action) && action.indexOf(reservedAction) !== -1;\n    if (isUsingReservedAction) throw new Error(`Cannot make an alias to \"${reservedAction}\" because this is reserved action`);\n\n    return actions.concat(action);\n  };\n\n  for (let i = 0; i < keys.length; i++) {\n    expandActions(aliasMap, keys[i], mergeAliasesAndDetectCycles);\n  }\n}\n\nexport type AliasResolverOptions = { skipValidate?: boolean; anyAction?: string };\nexport function createAliasResolver(aliasMap: AliasesMap, options?: AliasResolverOptions) {\n  if (!options || options.skipValidate !== false) {\n    validateForCycles(aliasMap, options && options.anyAction || 'manage');\n  }\n\n  return (action: string | string[]) => expandActions(aliasMap, action, defaultAliasMerge);\n}\n\nfunction copyArrayTo<T>(dest: T[], target: T[], start: number) {\n  for (let i = start; i < target.length; i++) {\n    dest.push(target[i]);\n  }\n}\n\nexport function mergePrioritized<T extends { priority: number }>(\n  array?: T[],\n  anotherArray?: T[]\n): T[] {\n  if (!array || !array.length) {\n    return anotherArray || [];\n  }\n\n  if (!anotherArray || !anotherArray.length) {\n    return array || [];\n  }\n\n  let i = 0;\n  let j = 0;\n  const merged: T[] = [];\n\n  while (i < array.length && j < anotherArray.length) {\n    if (array[i].priority < anotherArray[j].priority) {\n      merged.push(array[i]);\n      i++;\n    } else {\n      merged.push(anotherArray[j]);\n      j++;\n    }\n  }\n\n  copyArrayTo(merged, array, i);\n  copyArrayTo(merged, anotherArray, j);\n\n  return merged;\n}\n\nexport function getOrDefault<K, V>(map: Map<K, V>, key: K, defaultValue: () => V) {\n  let value = map.get(key);\n\n  if (!value) {\n    value = defaultValue();\n    map.set(key, value);\n  }\n\n  return value;\n}\n\nexport const identity = <T>(x: T) => x;\n","import { wrapArray, isSubjectType } from './utils';\nimport {\n  MatchConditions,\n  MatchField,\n  Abilities,\n  ToAbilityTypes,\n  Normalize,\n  ConditionsMatcher,\n  FieldMatcher,\n} from './types';\nimport { RawRule, RawRuleFrom } from './RawRule';\n\ntype Tuple<A extends Abilities> = Normalize<ToAbilityTypes<A>>;\n\nfunction validate(rule: RawRuleFrom<Abilities, any>, options: RuleOptions<any>) {\n  if (Array.isArray(rule.fields) && !rule.fields.length) {\n    throw new Error('`rawRule.fields` cannot be an empty array. https://bit.ly/390miLa');\n  }\n\n  if (rule.fields && !options.fieldMatcher) {\n    throw new Error('You need to pass \"fieldMatcher\" option in order to restrict access by fields');\n  }\n\n  if (rule.conditions && !options.conditionsMatcher) {\n    throw new Error('You need to pass \"conditionsMatcher\" option in order to restrict access by conditions');\n  }\n}\n\nexport interface RuleOptions<Conditions> {\n  conditionsMatcher?: ConditionsMatcher<Conditions>\n  fieldMatcher?: FieldMatcher\n  resolveAction(action: string | string[]): string | string[]\n}\n\nexport class Rule<A extends Abilities, C> {\n  private _matchConditions: MatchConditions | undefined;\n  private _matchField: MatchField<string> | undefined;\n  private readonly _options!: RuleOptions<C>;\n  public readonly action!: Tuple<A>[0] | Tuple<A>[0][];\n  public readonly subject!: Tuple<A>[1] | Tuple<A>[1][];\n  public readonly inverted!: boolean;\n  public readonly conditions!: C | undefined;\n  public readonly fields!: string[] | undefined;\n  public readonly reason!: string | undefined;\n  public readonly origin!: RawRule<ToAbilityTypes<A>, C>;\n  public readonly priority!: number;\n\n  constructor(\n    rule: RawRule<ToAbilityTypes<A>, C>,\n    options: RuleOptions<C>,\n    priority = 0\n  ) {\n    validate(rule, options);\n\n    this.action = options.resolveAction(rule.action);\n    this.subject = rule.subject!;\n    this.inverted = !!rule.inverted;\n    this.conditions = rule.conditions;\n    this.reason = rule.reason;\n    this.origin = rule;\n    this.fields = rule.fields ? wrapArray(rule.fields) : undefined;\n    this.priority = priority;\n    this._options = options;\n  }\n\n  private _conditionsMatcher() {\n    if (this.conditions && !this._matchConditions) {\n      this._matchConditions = this._options.conditionsMatcher!(this.conditions);\n    }\n\n    return this._matchConditions!;\n  }\n\n  get ast() {\n    const matches = this._conditionsMatcher();\n    return matches ? matches.ast : undefined;\n  }\n\n  matchesConditions(object: Normalize<A>[1] | undefined): boolean {\n    if (!this.conditions) {\n      return true;\n    }\n\n    if (!object || isSubjectType(object)) {\n      return !this.inverted;\n    }\n\n    const matches = this._conditionsMatcher();\n    return matches(object as Record<string, unknown>);\n  }\n\n  matchesField(field: string | undefined): boolean {\n    if (!this.fields) {\n      return true;\n    }\n\n    if (!field) {\n      // if there is no field (i.e., checking whether user has access to at least one field on subject)\n      // we ignore inverted rules because they disallow to do an action on it, so we are continue looking for regular rule\n      return !this.inverted;\n    }\n\n    if (!this._matchField) {\n      this._matchField = this._options.fieldMatcher!(this.fields);\n    }\n\n    return this._matchField(field);\n  }\n}\n","export interface LinkedItem<T> {\n  next: LinkedItem<T> | null\n  prev: LinkedItem<T> | null\n  readonly value: T\n}\n\nexport function linkedItem<T>(value: T, prev: LinkedItem<T>['prev']) {\n  const item = { value, prev, next: null };\n\n  if (prev) {\n    prev.next = item;\n  }\n\n  return item;\n}\n\nexport function unlinkItem(item: LinkedItem<any>) {\n  if (item.next) {\n    item.next.prev = item.prev;\n  }\n\n  if (item.prev) {\n    item.prev.next = item.next;\n  }\n\n  item.next = item.prev = null;\n}\n\nexport const cloneLinkedItem = <T extends LinkedItem<any>>(item: T): T => ({\n  value: item.value,\n  prev: item.prev,\n  next: item.next,\n} as T);\n","import { Rule, RuleOptions } from './Rule';\nimport { RawRuleFrom } from './RawRule';\nimport {\n  Abilities,\n  Normalize,\n  SubjectType,\n  AbilityParameters,\n  AbilityTuple,\n  ExtractSubjectType\n} from './types';\nimport { wrapArray, detectSubjectType, mergePrioritized, getOrDefault, identity, isSubjectType, DETECT_SUBJECT_TYPE_STRATEGY } from './utils';\nimport { LinkedItem, linkedItem, unlinkItem, cloneLinkedItem } from './structures/LinkedItem';\n\nexport interface RuleIndexOptions<A extends Abilities, C> extends Partial<RuleOptions<C>> {\n  detectSubjectType?(\n    subject: Exclude<Normalize<A>[1], SubjectType>\n  ): ExtractSubjectType<Normalize<A>[1]>;\n  anyAction?: string;\n  anySubjectType?: string;\n}\n\nexport declare const ɵabilities: unique symbol;\nexport declare const ɵconditions: unique symbol;\ninterface WithGenerics {\n  [ɵabilities]: any\n  [ɵconditions]: any\n}\nexport type Public<T extends WithGenerics> = { [K in keyof T]: T[K] };\nexport interface Generics<T extends WithGenerics> {\n  abilities: T[typeof ɵabilities],\n  conditions: T[typeof ɵconditions]\n}\n\nexport type RuleOf<T extends WithGenerics> =\n  Rule<Generics<T>['abilities'], Generics<T>['conditions']>;\nexport type RawRuleOf<T extends WithGenerics> =\n  RawRuleFrom<Generics<T>['abilities'], Generics<T>['conditions']>;\n\nexport type RuleIndexOptionsOf<T extends WithGenerics> =\n  RuleIndexOptions<Generics<T>['abilities'], Generics<T>['conditions']>;\n\ninterface AbilityEvent<T extends WithGenerics> {\n  target: T\n  /** @deprecated use \"target\" property instead */\n  ability: T\n}\n\nexport interface UpdateEvent<T extends WithGenerics> extends AbilityEvent<T> {\n  rules: RawRuleOf<T>[]\n}\n/**\n * @deprecated `on`/`emit` properly infer type without this type\n * TODO(major): delete\n */\nexport type EventHandler<Event> = (event: Event) => void;\n\nexport type Events<\n  T extends WithGenerics,\n  K extends keyof EventsMap<T> = keyof EventsMap<T>\n> = Map<K, LinkedItem<EventsMap<T>[K]> | null>;\n\ninterface EventsMap<T extends WithGenerics> {\n  update(event: UpdateEvent<T>): void\n  updated(event: UpdateEvent<T>): void\n}\n\ntype IndexTree<A extends Abilities, C> = Map<SubjectType, Map<string, {\n  rules: Rule<A, C>[],\n  merged: boolean\n}>>;\n\nexport type Unsubscribe = () => void;\n\nconst defaultActionEntry = () => ({\n  rules: [] as unknown as Rule<any, any>[],\n  merged: false\n});\nconst defaultSubjectEntry = () => new Map<string, ReturnType<typeof defaultActionEntry>>();\n\ntype AbilitySubjectTypeParameters<T extends Abilities, IncludeField extends boolean = true> =\n  AbilityParameters<\n  T,\n  T extends AbilityTuple\n    ? IncludeField extends true\n      ? (action: T[0], subject: ExtractSubjectType<T[1]>, field?: string) => 0\n      : (action: T[0], subject: ExtractSubjectType<T[1]>) => 0\n    : never,\n  (action: Extract<T, string>) => 0\n  >;\n\nexport class RuleIndex<A extends Abilities, Conditions> {\n  private _hasPerFieldRules = false;\n  private _events?: Events<this>;\n  private _indexedRules: IndexTree<A, Conditions> = new Map();\n  private _rules: RawRuleFrom<A, Conditions>[];\n  private readonly _ruleOptions: RuleOptions<Conditions>;\n  private _detectSubjectType: this['detectSubjectType'];\n  private readonly _anyAction: string;\n  private readonly _anySubjectType: string;\n  private readonly _hasCustomSubjectTypeDetection: boolean;\n  readonly [ɵabilities]!: A;\n  readonly [ɵconditions]!: Conditions;\n\n  constructor(\n    rules: RawRuleFrom<A, Conditions>[] = [],\n    options: RuleIndexOptions<A, Conditions> = {}\n  ) {\n    this._ruleOptions = {\n      conditionsMatcher: options.conditionsMatcher,\n      fieldMatcher: options.fieldMatcher,\n      resolveAction: options.resolveAction || identity,\n    };\n    this._anyAction = options.anyAction || 'manage';\n    this._anySubjectType = options.anySubjectType || 'all';\n    this._rules = rules;\n    this._hasCustomSubjectTypeDetection = !!options.detectSubjectType;\n    this._detectSubjectType = options.detectSubjectType || (detectSubjectType as this['detectSubjectType']);\n    this._indexAndAnalyzeRules(rules);\n  }\n\n  get rules() {\n    return this._rules;\n  }\n\n  detectSubjectType(object?: Normalize<A>[1]): ExtractSubjectType<Normalize<A>[1]> {\n    if (isSubjectType(object)) return object as ExtractSubjectType<Normalize<A>[1]>;\n    if (!object) return this._anySubjectType as ExtractSubjectType<Normalize<A>[1]>;\n    return this._detectSubjectType(object as Exclude<Normalize<A>[1], SubjectType>);\n  }\n\n  update(rules: RawRuleFrom<A, Conditions>[]): Public<this> {\n    const event = {\n      rules,\n      ability: this,\n      target: this\n    } as unknown as UpdateEvent<this>;\n\n    this._emit('update', event);\n    this._rules = rules;\n    this._indexAndAnalyzeRules(rules);\n    this._emit('updated', event);\n\n    return this;\n  }\n\n  private _indexAndAnalyzeRules(rawRules: RawRuleFrom<A, Conditions>[]) {\n    const indexedRules: IndexTree<A, Conditions> = new Map();\n    let typeOfSubjectType: string | undefined;\n\n    for (let i = rawRules.length - 1; i >= 0; i--) {\n      const priority = rawRules.length - i - 1;\n      const rule = new Rule(rawRules[i], this._ruleOptions, priority);\n      const actions = wrapArray(rule.action);\n      const subjects = wrapArray(rule.subject || this._anySubjectType);\n      if (!this._hasPerFieldRules && rule.fields) this._hasPerFieldRules = true;\n\n      for (let k = 0; k < subjects.length; k++) {\n        const subjectRules = getOrDefault(indexedRules, subjects[k], defaultSubjectEntry);\n        if (typeOfSubjectType === undefined) {\n          typeOfSubjectType = typeof subjects[k];\n        }\n        if (typeof subjects[k] !== typeOfSubjectType && typeOfSubjectType !== 'mixed') {\n          typeOfSubjectType = 'mixed';\n        }\n\n        for (let j = 0; j < actions.length; j++) {\n          getOrDefault(subjectRules, actions[j], defaultActionEntry).rules.push(rule);\n        }\n      }\n    }\n\n    this._indexedRules = indexedRules;\n    if (typeOfSubjectType !== 'mixed' && !this._hasCustomSubjectTypeDetection) {\n      const detectSubjectType = DETECT_SUBJECT_TYPE_STRATEGY[typeOfSubjectType as 'function' | 'string'] || DETECT_SUBJECT_TYPE_STRATEGY.string;\n      this._detectSubjectType = detectSubjectType as this['detectSubjectType'];\n    }\n  }\n\n  possibleRulesFor(...args: AbilitySubjectTypeParameters<A, false>): Rule<A, Conditions>[];\n  possibleRulesFor(\n    action: string,\n    subjectType: SubjectType = this._anySubjectType\n  ): Rule<A, Conditions>[] {\n    if (!isSubjectType(subjectType)) {\n      throw new Error('\"possibleRulesFor\" accepts only subject types (i.e., string or class) as the 2nd parameter');\n    }\n\n    const subjectRules = getOrDefault(this._indexedRules, subjectType, defaultSubjectEntry);\n    const actionRules = getOrDefault(subjectRules, action, defaultActionEntry);\n\n    if (actionRules.merged) {\n      return actionRules.rules;\n    }\n\n    const anyActionRules = action !== this._anyAction && subjectRules.has(this._anyAction)\n      ? subjectRules.get(this._anyAction)!.rules\n      : undefined;\n    let rules = mergePrioritized(actionRules.rules, anyActionRules);\n\n    if (subjectType !== this._anySubjectType) {\n      rules = mergePrioritized(rules, (this as any).possibleRulesFor(action, this._anySubjectType));\n    }\n\n    actionRules.rules = rules;\n    actionRules.merged = true;\n\n    return rules;\n  }\n\n  rulesFor(...args: AbilitySubjectTypeParameters<A>): Rule<A, Conditions>[];\n  rulesFor(action: string, subjectType?: SubjectType, field?: string): Rule<A, Conditions>[] {\n    const rules: Rule<A, Conditions>[] = (this as any).possibleRulesFor(action, subjectType);\n\n    if (field && typeof field !== 'string') {\n      throw new Error('The 3rd, `field` parameter is expected to be a string. See https://stalniy.github.io/casl/en/api/casl-ability#can-of-pure-ability for details');\n    }\n\n    if (!this._hasPerFieldRules) {\n      return rules;\n    }\n\n    return rules.filter(rule => rule.matchesField(field));\n  }\n\n  actionsFor(subjectType: ExtractSubjectType<Normalize<A>[1]>): string[] {\n    if (!isSubjectType(subjectType)) {\n      throw new Error('\"actionsFor\" accepts only subject types (i.e., string or class) as a parameter');\n    }\n\n    const actions = new Set<string>();\n\n    const subjectRules = this._indexedRules.get(subjectType);\n    if (subjectRules) {\n      Array.from(subjectRules.keys()).forEach(action => actions.add(action));\n    }\n\n    const anySubjectTypeRules = subjectType !== this._anySubjectType\n      ? this._indexedRules.get(this._anySubjectType)\n      : undefined;\n    if (anySubjectTypeRules) {\n      Array.from(anySubjectTypeRules.keys()).forEach(action => actions.add(action));\n    }\n\n    return Array.from(actions);\n  }\n\n  on<T extends keyof EventsMap<this>>(\n    event: T,\n    handler: EventsMap<Public<this>>[T]\n  ): Unsubscribe {\n    this._events = this._events || new Map();\n    const events = this._events;\n    const tail = events.get(event) || null;\n    const item = linkedItem(handler, tail);\n    events.set(event, item);\n\n    return () => {\n      const currentTail = events.get(event);\n\n      if (!item.next && !item.prev && currentTail === item) {\n        events.delete(event);\n      } else if (item === currentTail) {\n        events.set(event, item.prev);\n      }\n\n      unlinkItem(item);\n    };\n  }\n\n  private _emit<T extends keyof EventsMap<this>>(\n    name: T,\n    payload: Parameters<EventsMap<this>[T]>[0]\n  ) {\n    if (!this._events) return;\n\n    let current = this._events.get(name) || null;\n    while (current !== null) {\n      const prev = current.prev ? cloneLinkedItem(current.prev) : null;\n      current.value(payload);\n      current = prev;\n    }\n  }\n}\n","import { RuleIndex, RuleIndexOptions, RuleIndexOptionsOf, Public, RawRuleOf } from './RuleIndex';\nimport { Abilities, AbilityTuple, CanParameters, Subject } from './types';\nimport { Rule } from './Rule';\n\nexport interface AbilityOptions<A extends Abilities, Conditions>\n  extends RuleIndexOptions<A, Conditions> {}\nexport interface AnyAbility extends Public<PureAbility<any, any>> {}\nexport interface AbilityOptionsOf<T extends AnyAbility> extends RuleIndexOptionsOf<T> {}\n\nexport type AbilityClass<T extends AnyAbility> = new (\n  rules?: RawRuleOf<T>[],\n  options?: AbilityOptionsOf<T>\n) => T;\n\nexport type CreateAbility<T extends AnyAbility> = (\n  rules?: RawRuleOf<T>[],\n  options?: AbilityOptionsOf<T>\n) => T;\n\nexport class PureAbility<\n  A extends Abilities = AbilityTuple,\n  Conditions = unknown\n> extends RuleIndex<A, Conditions> {\n  can(...args: CanParameters<A>): boolean;\n  can(action: string, subject?: Subject, field?: string): boolean {\n    const rule = (this as PrimitiveAbility).relevantRuleFor(action, subject, field);\n    return !!rule && !rule.inverted;\n  }\n\n  relevantRuleFor(...args: CanParameters<A>): Rule<A, Conditions> | null;\n  relevantRuleFor(action: string, subject?: Subject, field?: string): Rule<A, Conditions> | null {\n    const subjectType = this.detectSubjectType(subject);\n    const rules = (this as any).rulesFor(action, subjectType, field);\n\n    for (let i = 0, length = rules.length; i < length; i++) {\n      if (rules[i].matchesConditions(subject)) {\n        return rules[i];\n      }\n    }\n\n    return null;\n  }\n\n  cannot(...args: CanParameters<A>): boolean;\n  cannot(action: string, subject?: Subject, field?: string): boolean {\n    return !(this as PrimitiveAbility).can(action, subject, field);\n  }\n}\n\n/**\n * helper interface that helps to emit js methods that have static parameters\n */\ninterface PrimitiveAbility<A extends Abilities = AbilityTuple, Conditions = unknown> {\n  can(action: string, subject?: Subject, field?: string): boolean;\n  relevantRuleFor(action: string, subject?: Subject, field?: string): Rule<A, Conditions> | null\n}\n","import {\n  $all,\n  $elemMatch,\n  $eq,\n  $exists,\n  $gt,\n  $gte,\n  $in,\n  $lt,\n  $lte,\n  $ne,\n  $nin,\n  $options,\n  $regex,\n  $size,\n  all,\n  and,\n  BuildMongoQuery,\n  createFactory,\n  DefaultOperators,\n  elemMatch,\n  eq,\n  exists,\n  gt,\n  gte,\n  lt,\n  lte,\n  ne,\n  nin,\n  regex,\n  size,\n  within\n} from '@ucast/mongo2js';\nimport { Container, GenericFactory } from '../hkt';\nimport { AnyObject, ConditionsMatcher } from '../types';\n\nconst defaultInstructions = {\n  $eq,\n  $ne,\n  $lt,\n  $lte,\n  $gt,\n  $gte,\n  $in,\n  $nin,\n  $all,\n  $size,\n  $regex,\n  $options,\n  $elemMatch,\n  $exists,\n};\nconst defaultInterpreters = {\n  eq,\n  ne,\n  lt,\n  lte,\n  gt,\n  gte,\n  in: within,\n  nin,\n  all,\n  size,\n  regex,\n  elemMatch,\n  exists,\n  and,\n};\n\ninterface MongoQueryFactory extends GenericFactory {\n  produce: MongoQuery<this[0]>\n}\n\ntype MergeUnion<T, Keys extends keyof T = keyof T> = { [K in Keys]: T[K] };\nexport type MongoQuery<T = AnyObject> = BuildMongoQuery<MergeUnion<T>, {\n  toplevel: {},\n  field: Pick<DefaultOperators<MergeUnion<T>>['field'], keyof typeof defaultInstructions>\n}> & Container<MongoQueryFactory>;\n\ntype MongoQueryMatcherFactory =\n  (...args: Partial<Parameters<typeof createFactory>>) => ConditionsMatcher<MongoQuery>;\nexport const buildMongoQueryMatcher = ((instructions, interpreters, options) => createFactory(\n  { ...defaultInstructions, ...instructions },\n  { ...defaultInterpreters, ...interpreters },\n  options\n)) as MongoQueryMatcherFactory;\n\nexport const mongoQueryMatcher = createFactory(defaultInstructions, defaultInterpreters);\nexport type {\n  MongoQueryFieldOperators, MongoQueryOperators, MongoQueryTopLevelOperators\n} from '@ucast/mongo2js';\n\n","import { FieldMatcher } from '../types';\n\nconst REGEXP_SPECIAL_CHARS = /[-/\\\\^$+?.()|[\\]{}]/g;\nconst REGEXP_ANY = /\\.?\\*+\\.?/g;\nconst REGEXP_STARS = /\\*+/;\nconst REGEXP_DOT = /\\./g;\n\nfunction detectRegexpPattern(match: string, index: number, string: string): string {\n  const quantifier = string[0] === '*' || match[0] === '.' && match[match.length - 1] === '.'\n    ? '+'\n    : '*';\n  const matcher = match.indexOf('**') === -1 ? '[^.]' : '.';\n  const pattern = match.replace(REGEXP_DOT, '\\\\$&')\n    .replace(REGEXP_STARS, matcher + quantifier);\n\n  return index + match.length === string.length ? `(?:${pattern})?` : pattern;\n}\n\nfunction escapeRegexp(match: string, index: number, string: string): string {\n  if (match === '.' && (string[index - 1] === '*' || string[index + 1] === '*')) {\n    return match;\n  }\n\n  return `\\\\${match}`;\n}\n\nfunction createPattern(fields: string[]) {\n  const patterns = fields.map(field => field\n    .replace(REGEXP_SPECIAL_CHARS, escapeRegexp)\n    .replace(REGEXP_ANY, detectRegexpPattern));\n  const pattern = patterns.length > 1 ? `(?:${patterns.join('|')})` : patterns[0];\n\n  return new RegExp(`^${pattern}$`);\n}\n\nexport const fieldPatternMatcher: FieldMatcher = (fields) => {\n  let pattern: RegExp | null;\n\n  return (field) => {\n    if (typeof pattern === 'undefined') {\n      pattern = fields.every(f => f.indexOf('*') === -1)\n        ? null\n        : createPattern(fields);\n    }\n\n    return pattern === null\n      ? fields.indexOf(field) !== -1\n      : pattern.test(field);\n  };\n};\n","import { PureAbility, AbilityOptions, AbilityOptionsOf } from './PureAbility';\nimport { RawRuleFrom } from './RawRule';\nimport { AbilityTuple } from './types';\nimport { MongoQuery, mongoQueryMatcher } from './matchers/conditions';\nimport { fieldPatternMatcher } from './matchers/field';\nimport { Public, RawRuleOf } from './RuleIndex';\n\n/**\n * @deprecated use createMongoAbility function instead and MongoAbility<Abilities> interface.\n * In the next major version PureAbility will be renamed to Ability and this class will be removed\n */\nexport class Ability<\n  A extends AbilityTuple = AbilityTuple,\n  C extends MongoQuery = MongoQuery\n> extends PureAbility<A, C> {\n  constructor(rules: RawRuleFrom<A, C>[] = [], options: AbilityOptions<A, C> = {}) {\n    super(rules, {\n      conditionsMatcher: mongoQueryMatcher,\n      fieldMatcher: fieldPatternMatcher,\n      ...options,\n    });\n  }\n}\n\nexport interface AnyMongoAbility extends Public<PureAbility<any, MongoQuery>> {}\nexport interface MongoAbility<\n  A extends AbilityTuple = AbilityTuple,\n  C extends MongoQuery = MongoQuery\n> extends PureAbility<A, C> {}\n\n/**\n * Creates Ability with MongoDB conditions matcher\n */\nexport function createMongoAbility<\n  T extends AnyMongoAbility = MongoAbility\n>(rules?: RawRuleOf<T>[], options?: AbilityOptionsOf<T>): T;\nexport function createMongoAbility<\n  A extends AbilityTuple = AbilityTuple,\n  C extends MongoQuery = MongoQuery\n>(rules?: RawRuleFrom<A, C>[], options?: AbilityOptions<A, C>): MongoAbility<A, C>;\nexport function createMongoAbility(rules: any[] = [], options = {}): AnyMongoAbility {\n  return new PureAbility(rules, {\n    conditionsMatcher: mongoQueryMatcher,\n    fieldMatcher: fieldPatternMatcher,\n    ...options,\n  });\n}\n","import { AnyMongoAbility, createMongoAbility, MongoAbility } from './Ability';\nimport { ProduceGeneric } from './hkt';\nimport { AbilityOptionsOf, AnyAbility } from './PureAbility';\nimport { Generics, RawRuleOf } from './RuleIndex';\nimport {\n  AbilityTuple, AnyClass, AnyObject, ExtractSubjectType as E, Normalize, SubjectType,\n  TaggedInterface\n} from './types';\n\nfunction isAbilityClass(factory: AbilityFactory<any>): factory is AnyClass {\n  return factory.prototype !== undefined && typeof factory.prototype.possibleRulesFor === 'function';\n}\n\nclass RuleBuilder<T extends AnyAbility> {\n  public _rule!: RawRuleOf<T>;\n\n  constructor(rule: RawRuleOf<T>) {\n    this._rule = rule;\n  }\n\n  because(reason: string): this {\n    this._rule.reason = reason;\n    return this;\n  }\n}\n\ntype AbilityFactory<T extends AnyAbility> = AnyClass<T> | ((rules?: any[], options?: any) => T);\ntype InstanceOf<T extends AnyAbility, S extends SubjectType> = S extends AnyClass<infer R>\n  ? R\n  : S extends (...args: any[]) => infer O\n    ? O\n    : S extends string\n      ? Exclude<Normalize<Generics<T>['abilities']>[1], SubjectType> extends TaggedInterface<string>\n        ? Extract<Normalize<Generics<T>['abilities']>[1], TaggedInterface<S>>\n        : AnyObject\n      : never;\ntype ConditionsOf<T extends AnyAbility, I extends {}> =\n  ProduceGeneric<Generics<T>['conditions'], I>;\ntype ActionFrom<T extends AbilityTuple, S extends SubjectType> = T extends any\n  ? S extends Extract<T[1], SubjectType> ? T[0] : never\n  : never;\ntype ActionOf<T extends AnyAbility, S extends SubjectType> = ActionFrom<Generics<T>['abilities'], S>;\ntype SubjectTypeOf<T extends AnyAbility> = E<Normalize<Generics<T>['abilities']>[1]>;\n\ntype SimpleCanParams<T extends AnyAbility> = Parameters<(\n  action: Generics<T>['abilities'] | Generics<T>['abilities'][]\n) => 0>;\ntype BuilderCanParameters<\n  S extends SubjectType,\n  I extends InstanceOf<T, S>,\n  T extends AnyAbility\n> = Generics<T>['abilities'] extends AbilityTuple\n  ? Parameters<(\n    action: ActionOf<T, S> | ActionOf<T, S>[],\n    subject: S | S[],\n    conditions?: ConditionsOf<T, I>\n  ) => 0>\n  : SimpleCanParams<T>;\n\ntype BuilderCanParametersWithFields<\n  S extends SubjectType,\n  I extends InstanceOf<T, S>,\n  F extends string,\n  T extends AnyAbility\n> = Generics<T>['abilities'] extends AbilityTuple\n  ? Parameters<(\n    action: ActionOf<T, S> | ActionOf<T, S>[],\n    subject: S | S[],\n    fields?: F | F[],\n    conditions?: ConditionsOf<T, I>\n  ) => 0>\n  : SimpleCanParams<T>;\ntype Keys<T> = string & keyof T;\n\ntype AddRule<T extends AnyAbility> = {\n  <\n    I extends InstanceOf<T, S>,\n    F extends string = Keys<I>,\n    S extends SubjectTypeOf<T> = SubjectTypeOf<T>\n  >(...args: BuilderCanParametersWithFields<S, I, F | Keys<I>, T>): RuleBuilder<T>;\n  <\n    I extends InstanceOf<T, S>,\n    S extends SubjectTypeOf<T> = SubjectTypeOf<T>\n  >(...args: BuilderCanParameters<S, I, T>): RuleBuilder<T>;\n};\n\nexport class AbilityBuilder<T extends AnyAbility> {\n  public rules: RawRuleOf<T>[] = [];\n  private readonly _createAbility: AbilityFactory<T>;\n  public can: AddRule<T>;\n  public cannot: AddRule<T>;\n  public build: (options?: AbilityOptionsOf<T>) => T;\n\n  constructor(AbilityType: AbilityFactory<T>) {\n    this._createAbility = AbilityType;\n\n    this.can = (\n      action: string | string[],\n      subject?: SubjectType | SubjectType[],\n      conditionsOrFields?: string | string[] | Generics<T>['conditions'],\n      conditions?: Generics<T>['conditions']\n    ) => this._addRule(action, subject, conditionsOrFields, conditions, false);\n    this.cannot = (\n      action: string | string[],\n      subject?: SubjectType | SubjectType[],\n      conditionsOrFields?: string | string[] | Generics<T>['conditions'],\n      conditions?: Generics<T>['conditions']\n    ) => this._addRule(action, subject, conditionsOrFields, conditions, true);\n\n    this.build = options => (isAbilityClass(this._createAbility)\n      ? new this._createAbility(this.rules, options)\n      : this._createAbility(this.rules, options));\n  }\n\n  private _addRule(\n    action: string | string[],\n    subject?: SubjectType | SubjectType[],\n    conditionsOrFields?: string | string[] | Generics<T>['conditions'],\n    conditions?: Generics<T>['conditions'],\n    inverted?: boolean\n  ): RuleBuilder<T> {\n    const rule = { action } as RawRuleOf<T>;\n\n    if (inverted) rule.inverted = inverted;\n    if (subject) {\n      rule.subject = subject;\n\n      if (Array.isArray(conditionsOrFields) || typeof conditionsOrFields === 'string') {\n        rule.fields = conditionsOrFields;\n      } else if (typeof conditionsOrFields !== 'undefined') {\n        rule.conditions = conditionsOrFields;\n      }\n\n      if (typeof conditions !== 'undefined') {\n        rule.conditions = conditions;\n      }\n    }\n\n    this.rules.push(rule);\n    return new RuleBuilder(rule);\n  }\n}\n\ntype DSL<T extends AnyAbility, R> = (\n  can: AbilityBuilder<T>['can'],\n  cannot: AbilityBuilder<T>['cannot']\n) => R;\n\nexport function defineAbility<\n  T extends AnyMongoAbility = MongoAbility\n>(define: DSL<T, Promise<void>>, options?: AbilityOptionsOf<T>): Promise<T>;\nexport function defineAbility<\n  T extends AnyMongoAbility = MongoAbility\n>(define: DSL<T, void>, options?: AbilityOptionsOf<T>): T;\nexport function defineAbility<\n  T extends AnyMongoAbility\n>(define: DSL<T, void | Promise<void>>, options?: AbilityOptionsOf<T>): T | Promise<T> {\n  const builder = new AbilityBuilder<T>(createMongoAbility);\n  const result = define(builder.can, builder.cannot);\n\n  if (result && typeof result.then === 'function') {\n    return result.then(() => builder.build(options));\n  }\n\n  return builder.build(options);\n}\n","import { AnyAbility } from './PureAbility';\nimport { Normalize, Subject } from './types';\nimport { Generics } from './RuleIndex';\nimport { getSubjectTypeName } from './utils';\n\nexport type GetErrorMessage = (error: ForbiddenError<AnyAbility>) => string;\n/** @deprecated will be removed in the next major release */\nexport const getDefaultErrorMessage: GetErrorMessage = error => `Cannot execute \"${error.action}\" on \"${error.subjectType}\"`;\n\nconst NativeError = function NError(this: Error, message: string) {\n  this.message = message;\n} as unknown as new (message: string) => Error;\n\nNativeError.prototype = Object.create(Error.prototype);\n\nexport class ForbiddenError<T extends AnyAbility> extends NativeError {\n  public readonly ability!: T;\n  public action!: Normalize<Generics<T>['abilities']>[0];\n  public subject!: Generics<T>['abilities'][1];\n  public field?: string;\n  public subjectType!: string;\n\n  static _defaultErrorMessage = getDefaultErrorMessage;\n\n  static setDefaultMessage(messageOrFn: string | GetErrorMessage) {\n    this._defaultErrorMessage = typeof messageOrFn === 'string' ? () => messageOrFn : messageOrFn;\n  }\n\n  static from<U extends AnyAbility>(ability: U): ForbiddenError<U> {\n    return new this<U>(ability);\n  }\n\n  constructor(ability: T) {\n    super('');\n    this.ability = ability;\n\n    if (typeof Error.captureStackTrace === 'function') {\n      this.name = 'ForbiddenError';\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n\n  setMessage(message: string): this {\n    this.message = message;\n    return this;\n  }\n\n  throwUnlessCan(...args: Parameters<T['can']>): void;\n  throwUnlessCan(action: string, subject?: Subject, field?: string): void {\n    const error = (this as any).unlessCan(action, subject, field);\n    if (error) throw error;\n  }\n\n  unlessCan(...args: Parameters<T['can']>): this | undefined;\n  unlessCan(action: string, subject?: Subject, field?: string): this | undefined {\n    const rule = this.ability.relevantRuleFor(action, subject, field);\n\n    if (rule && !rule.inverted) {\n      return;\n    }\n\n    this.action = action;\n    this.subject = subject;\n    this.subjectType = getSubjectTypeName(this.ability.detectSubjectType(subject));\n    this.field = field;\n\n    const reason = rule ? rule.reason : '';\n    this.message = this.message || reason || (this.constructor as any)._defaultErrorMessage(this);\n    return this;\n  }\n}\n"],"names":["hasOwn","Object","obj","prop","prototype","hasOwnProperty","call","wrapArray","value","Array","isArray","TYPE_FIELD","setSubjectType","type","object","defineProperty","Error","isSubjectType","getSubjectClassName","modelName","name","getSubjectTypeName","detectSubjectType","constructor","DETECT_SUBJECT_TYPE_STRATEGY","function","string","expandActions","aliasMap","rawActions","merge","actions","i","length","action","findDuplicate","actionToFind","indexOf","defaultAliasMerge","concat","validateForCycles","reservedAction","keys","mergeAliasesAndDetectCycles","duplicate","join","isUsingReservedAction","createAliasResolver","options","skipValidate","anyAction","copyArrayTo","dest","target","start","push","mergePrioritized","array","anotherArray","j","merged","priority","getOrDefault","map","key","defaultValue","get","set","identity","x","validate","rule","fields","fieldMatcher","conditions","conditionsMatcher","Rule","this","resolveAction","subject","inverted","reason","origin","undefined","_options","_proto","_conditionsMatcher","_matchConditions","matchesConditions","matches","matchesField","field","_matchField","_createClass","ast","linkedItem","prev","item","next","unlinkItem","cloneLinkedItem","defaultActionEntry","rules","defaultSubjectEntry","Map","RuleIndex","_hasPerFieldRules","_indexedRules","_ruleOptions","_anyAction","_anySubjectType","anySubjectType","_rules","_hasCustomSubjectTypeDetection","_detectSubjectType","_indexAndAnalyzeRules","update","event","ability","_emit","rawRules","indexedRules","typeOfSubjectType","subjects","k","subjectRules","possibleRulesFor","subjectType","actionRules","anyActionRules","has","rulesFor","filter","actionsFor","Set","from","forEach","add","anySubjectTypeRules","on","handler","_events","events","tail","currentTail","delete","payload","current","PureAbility","_RuleIndex","apply","arguments","_inheritsLoose","can","relevantRuleFor","cannot","defaultInstructions","$eq","$ne","$lt","$lte","$gt","$gte","$in","$nin","$all","$size","$regex","$options","$elemMatch","$exists","defaultInterpreters","eq","ne","lt","lte","gt","gte","in","within","nin","all","size","regex","elemMatch","exists","and","buildMongoQueryMatcher","instructions","interpreters","createFactory","_extends","mongoQueryMatcher","REGEXP_SPECIAL_CHARS","REGEXP_ANY","REGEXP_STARS","REGEXP_DOT","detectRegexpPattern","match","index","quantifier","matcher","pattern","replace","escapeRegexp","createPattern","patterns","RegExp","fieldPatternMatcher","every","f","test","Ability","_PureAbility","createMongoAbility","isAbilityClass","factory","RuleBuilder","_rule","because","AbilityBuilder","AbilityType","_this","_createAbility","conditionsOrFields","_addRule","build","_proto2","defineAbility","define","builder","result","then","getDefaultErrorMessage","error","NativeError","NError","message","create","ForbiddenError","_NativeError","captureStackTrace","setDefaultMessage","messageOrFn","_defaultErrorMessage","setMessage","throwUnlessCan","unlessCan"],"mappings":"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"}